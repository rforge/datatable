\documentclass[a4paper]{article}

\usepackage[margin=2cm]{geometry}
\usepackage[round]{natbib}
\usepackage{url}

\newcommand{\acronym}[1]{\textsc{#1}}
\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\proglang}[1]{\textsf{#1}}

%% \VignetteIndexEntry{Introduction to the data.table Package}

\begin{document}
<<echo=FALSE,results=hide>>=
library("data.table")
@
\title{Introduction to the \pkg{data.table} Package in \proglang{R}}
\author{Matthew Dowle}
\maketitle

\section*{Introduction}

This vignette is aimed at those who are already familiar with \proglang{R}, in
particular creating and using objects of class data.frame. We aim for this quick introduction
to be readable in {\bf10 minutes}, covering the main features in brief. The main features are the section
titles which you can flick through now : 1.Keys, 2.Fast Merging, 3.Fast Grouping

data.table is not \emph{automatically} better or faster. Although syntax and techniques on a
data.frame may also work with a data.table, it is your responsibility to make yourself
aware of the features, to experiment, and to use the features well.

\section*{Creation}

Recall that we create a \code{data.frame} like this :
<<keep.source=TRUE>>=
df = data.frame(a=c("b","b","b","a","a"),b=1:5)
df
@
We create a data.table in exactly the same way, like this :
<<keep.source=TRUE>>=
dt = data.table(a=c("b","b","b","a","a"),b=1:5)
dt
@
Observe that a data.table prints the row numbers slightly differently. There is nothing
significant about that.
We can also convert existing data.frame objects to data.table like this :
<<keep.source=TRUE>>=
irisdt = data.table(iris)
head(irisdt)
@
We have just created two data.tables. It is often useful to see a list of all our
data.tables in memory :
<<keep.source=TRUE>>=
tables()
@

Some users work will 20 or perhaps 100+ data.table's in memory, rather like a database. The result is itself
a data.table, returned silently, so tables() is also sometimes used in programs. tables() is unrelated to 
the base function table().

The MB column is useful to quickly assess memory use and to spot if any redundant tables can be
removed to free up memory. Just like data.frame's, data.table's must fit inside RAM. 

You may have noticed the empty KEY column. This is the subject of the next section.


\section*{1. Keys}

Lets start by considering data.frame, specifically ''rownames''. Or in English ''row names''. That is, the
multiple names belonging to the single row.  Hang on, what was that just written?  The multiple names belonging
to the single row?  No, that is not what we are used to in a data.frame. We know that each row has at
most one name, but never \emph{more} than one name.  A person has at least two names, a first name and a second
name, but rows in a data.frame can only have one name.  Why only one name?

A \emph{key} is several columns of rownames. These columns may be integer, factor or other classes, not
just character. Furthermore, the rows are guaranteed to be sorted by the columns in the key.

More formally :

A data.table by default has no key.  If it has a key then its key :
\begin{itemize}
\item	is an ordered list of one or more column names
\item   defines the order of the rows in the table
\end{itemize}

Note here that uniqueness is not enforced i.e. duplicate key values are allowed. However, since
the rows are sorted by the key, any duplicates in the key will appear consecutively.

Why are keys useful ?  Lets first consider an analogy before moving on to demonstrate using examples.
Some people don't like analogies, some do. The former should skip the following paragraph.

A traditional door key has a sequence of notches which uniquely identify one door. By \emph{notch},
think \emph{name}. By \emph{door} think \emph{row}. The key
opens no other doors, and the door responds to no other keys. In a hotel with 5 floors, management may wish to
allow housemaid Emily access to all rooms on floor 1 but no other floors. Similarly management may wish to assign
housemaid Sophie to floor 2, etc.  This may be considered by management a good incentive to disuade housemaids from
stealing from the guests.  A door key could be designed with up to 3 notches.  Guests would be given a key with 3
notches which only opened their room.  Housemaids would have a key with 2 notches, which opened all the rooms on their
floor.  Management would have a key with 1 notch which would open all rooms on all floors.  The more notches in the key,
the more specifically it identifies the rooms.  Each room is identified by more than one notch in the key. You do not
need to use all the notches (management use 1, housemaids use 2, guests use 3).

Lets remind ourselves of our tables :
<<>>=
tables()
dt
@

No keys have been set yet.  We \emph{can} do data.frame like operations without a key :

<<>>=
dt[2,]
dt[ dt$a == "a", ]
@

But since there are no rownames the following does not work :
<<>>=
cat(try(dt["b",]))
@

The error message tells us we need to use setkey()

<<>>=
setkey(dt,a)
dt
tables()
@

The data.table dt now has a key of one column, a.  sekey re-ordered
the rows, and marked the table as sorted by a.  A key is therefore very simple.

Lets try again :

<<>>=
dt["b",]
@

Since there are duplicates in this key, the subset returns the first by default. The mult argument controls this.

<<>>=
dt["b",mult="first"]
dt["b",mult="last"]
dt["b",mult="all"]
@

TO DO- example with two columns in the key, make it large and explain difference between vector scan and binary search. Advise to unlearn ==.

First section was to do with i. Second section to do with j.

\section*{2. Fast grouping}

So far we have dealt with the first argument inside []. The first is call i. The second is called j and may
be an expression, or list of expressions, of column names as if the column names were variables.

When we supply a j expression and a 'by' list of expressions, the j expression is repeated for each group defined
by the 'by'.

TO DO - examples.

\section*{3. Fast joining/merging}

x[y] is a join between x and y,  a subset of x defined by y
merge(x,y) is the same but contains the union of columns.  When merge is passed data.table's, it operates much
faster than base merge on data.frame's.

TO DO - examples.

\section*{Other resources}

This was a quick start guide. Further resources include :
\begin{itemize}
\item The help page describes each and every argument \code{?"[.data.table"}
\item The FAQs deal with distinct topics in an easy to digest manner
\item The performance tests are more complex real world examples
\item test.data.table contains over 100 low level tests of the features.
\end{itemize}

\end{document}


