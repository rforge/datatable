\documentclass[a4paper]{article}

\usepackage[margin=3cm]{geometry}
%%\usepackage[round]{natbib}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}

%%\newcommand{\acronym}[1]{\textsc{#1}}
%%\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\proglang}[1]{\textsf{#1}}
\SweaveOpts{keep.source=TRUE}
%% \VignetteIndexEntry{Frequently asked questions}

<<echo=FALSE,results=hide>>=
if (!exists("data.table",.GlobalEnv)) library(data.table)  # see Intro.Rnw for comments on these two lines
rm(list=as.character(tables()$NAME))
options(width=70)  # so lines wrap round
@


\begin{document}
\title{FAQs about the \pkg{data.table} package in \proglang{R}}
\author{Matthew Dowle}
\date{\today\\(A later revision may be available on the \href{http://datatable.r-forge.r-project.org/}{homepage})}
\maketitle

The first section, Beginner FAQs, is intended to be read in order from start to finish. It may
be read before reading the Introduction vignette.

\tableofcontents
\section{Beginner FAQs}

\subsection{Why does \code{DT[,5]} return \code{5} ?}
Because, by default, unlike a \code{data.frame}, the 2nd argument is an \emph{expression}
which is evaluated within the scope of \code{DT}. 5 evaluates to 5. It is generally bad practice to refer
to columns by number rather than name. If someone else comes along and reads your code later, they
may have to hunt around to find out which column is number 5. Furthermore, if you or someone else
changes the column ordering of \code{DT} higher up in your R program, you might get bugs if you forget to
change all the places in your code which refer to column number 5.

Say column 5 is called ''region'', just do \code{DT[,region]} instead. Notice there are no quotes around
the column name. This is what we mean by j being evaluated within the scope of the \code{data.table}. That
scope consists of an environment where the column names are variables.

You can write \emph{any} R expression in the \code{j} e.g. \code{DT[,colA*colB/2]}. Further, \code{j} may be a \code{list()} of many R expressions, including calls to any R package e.g. \code{DT[,fitdistr(d1-d1,"normal")]}.

Having said this, there are some circumstances where referring to a column by number is ok, such as
a sequence of columns. In these situations just do \code{DT[,5:10,with=FALSE]} or \newline \code{DT[,c(1,4,10),with=FALSE]}.
See \code{?"[.data.table"} for an explanation of the \code{with} argument.

Note that \code{with()} has been a base function for a long time.  That's one reason we say \code{data.table} builds
upon base functionality. There is little new here really, \code{data.table} is just making use of \code{with()}
and building it into the syntax.

\subsection{Why does \code{DT[,"region"]} return \code{"region"}?}
See answer to 1.1 above. Try \code{DT[,region]} instead. Or \code{DT[,"region",with=FALSE]}.


\subsection{Why does \code{DT[,region]} return a vector?  I'd like a 1-column \code{data.table}. There is no drop argument like I'm used to in \code{data.frame}.}
Try \code{DT[,list(region)]} instead.

\subsection{Why does \code{DT[,x,y,z]} not work? I wanted the 3 columns x,y and z.}
The \code{j} expression is the 2nd argument. The correct way to do this is \code{DT[,list(x,y,z)]}.

\subsection{I assigned a variable \code{mycol="x"} but then \code{DT[,mycol]} returns \code{"x"}. How do I get it to look up the column name contained in the \code{mycol} variable?}
This is what we mean when we say the \code{j} expression 'sees' objects in the calling scope. The variable \code{mycol} does not exist as a column name of
DT so R then looked in the calling scope and found \code{mycol} there, and returned its value \code{"x"}. This is correct behaviour. Had \code{mycol} been a column name,
then that column's data would have been returned. What you probably meant was \code{DT[,mycol,with=FALSE]}, which will return the \code{x} column's 
data as you wanted. Alternatively, since a \code{data.table} is just a list, you can do \code{DT[["x"]]} or \code{DT[[mycol]]}.

\subsection{Ok but I don't know the expressions in advance. How do I programatically pass them in?}
To create expressions use the \code{quote()} function. We refer to these as \emph{quote()-ed} expressions to
save confusion with the double quotes used to create a character vector such as \code{c("x")}. The simplest
quote()-ed expression is just a column name on it's own :

\code{q = quote(x)}

\code{DT[,eval(q)]  \# returns the column x as a vector}

\code{q = quote(list(x))}

\code{DT[,eval(q)]  \# returns the column x as a 1-column data.table}
\newline
Since these are \emph{expressions}, we are not restricted to column names only :

\code{q = quote(mean(x))}

\code{DT[,eval(q)]  \# identical to DT[,mean(x)]}

\code{q = quote(list(x,sd(y),mean(y*z)))}

\code{DT[,eval(q)]  \# identical to DT[,list(x,sd(y),mean(y*z))]}
\newline
If it's just simply a vector of column names it may be simpler to pass a character vector to \code{j} and use \code{with=FALSE}.

\subsection{This is really hard. What's the point ?}
\code{j} doesn't have to be just column names. You can put any R expression of column names directly as the \code{j}, e.g., 
\code{DT[,mean(x*y/z)]}.  The same applies
to \code{i}. You have been used to \code{i} being row numbers or row names only. It's nice to simply write \code{DT[x>1000, sum(y*z)]}. 
What does that mean? It
just runs the \code{j} expression on the set of rows where the \code{i} expression is true. \code{i} can be any expression of column names 
that evaluates to logical. You don't even need to return data, e.g., \code{DT[x>1000, plot(y,z)]}. 
When we get to compound table joins we will see how \code{i} and \code{j} can themselves be other \code{data.table} queries. 
We are going to stretch \code{i} and \code{j} much further than this, but to get there we need you on board first with FAQs 1.1-1.6.

\subsection{OK, I'm starting to see what \code{data.table} is about, but why didn't you enhance \code{data.frame} in \proglang{R}? Why does it have to be a new package?}
As FAQ 1.1 highlights, \code{j} in \code{[.data.table} is fundamentally different from \code{j} in \code{[.data.frame}. Even something as simple as \code{DF[,1]} would break existing code in many packages and user code.  This is by design, and we want it to work this way for more complicated syntax to work. There are other differences, too.

However, we \emph{have} proposed enhancements to \proglang{R} wherever possible, and some of these have been accepted and included. We intend to continue attempts to contribute to \proglang{R} itself whenever an opportunity arises.

\subsection{Why are the defaults the way they are? Why does it work the way it does?}
The simple answer is because the author designed it for his own use, and he wanted it that way. He finds it a more natural, faster way to
write code, which also executes more quickly.

\subsection{Isn't this already done by \code{with()} and \code{subset()} in base?}
Some of the features discussed so far are, yes. The package builds upon base functionality. It does the same sorts of things but with
less code required, and executes many times faster if used correctly.

\subsection{Why does \code{x[y]} just return the columns from x? Shouldn't it return the y columns too?}
Good question.  The thinking was that, more often than not, you don't actually want the columns from y which aren't in the key. By
default, we try to keep things efficient.  In general, we don't want to create memory for the union of things, only to select out a
few columns from it in the end. So if you want the computer to do more work, then you need to tell it do more work. You can either do
\code{cbind(y,x[y])} or \code{merge(x,y)}.  There are many different ways to do the same thing in \code{data.table}.  It's your choice to understand the
differences and write good code.
The other consideration is that \code{x[y]} is after all a subset of x. The ''['' operator does mean subset. 
By default, we thought it was more consistent with base R for \code{x[y]} to just return the columns from x.
However, it is now apparent that \code{x[y]} returning all columns from both tables would be useful, so an argument \code{inci} will be added. We
mentioned the merge method for \code{data.table} too, but does \code{merge(x,y)} mean \code{x[y]} or \code{y[x]}?  Those are different things. Again, it is
your choice which syntax you prefer and find clearer.\newline
Finally, although it appears as though \code{x[y]} does not return the columns in y, you can actually use the columns from y in the \code{j}
expression.  This is what we mean by \emph{join inherited scope}.  Why not just return the union of all the columns from x and y and
then run expressions on that?  It boils down to efficiency of code and what is quicker to program.  When you write \code{x[y,foo*boo]}, 
\code{data.table} automatically inspects the \code{j} expression to see which columns it uses.  It will only subset, or group, those columns only.  Memory
is only created for the columns the \code{j} uses.  Let's say foo is in x, and boo is in y (along with 20 other columns in y). Isn't
x[y,foo*boo] quicker to program and quicker to run than a merge step followed by another subset step ?


\section{General syntax}

\subsection{How can I avoid writing a really long \code{j} expression? You've said I should use the column names, but I've got loads of them.}
There is a special \code{.SD} object, which stands for Sub Data.  The \code{j} expression can use column names as variables, as you know, but it can
also use \code{.SD}, which refers to the sub \code{data.table} as a whole.  So to sum up all your columns it's just \code{DT[,lapply(.SD,sum),by=grp]}. It might
seem tricky, but it's fast to write and fast to run. Notice you don't have to create an anonymous function(). See the timing vignette and
comparison to other methods. The \code{.SD} object is efficiently implemented internally and more efficient than passing an argument to a function.
Please don't do this though :   \code{DT[,.SD[,"sales",with=FALSE],by=grp]}. That `works', but is very inefficient and inelegant. This is what
was intended: \code{DT[,sum(x),by=grp]} and could be 100's of times faster if DT contains many columns. No \code{data.table} may contain a column
called .SD, that's why it has a ''.'' at the start as you are unlikely to really want a column called ''.SD''.


\subsection{Why is the default for mult "first" ?  If there are duplicates in the key, shouldn't it return them all by default?}
Possibly, yes. The default might be changed to "all".

In versions up to v1.3, "all" was slower. Internally, "all" was implemented by joining using "first", then again from scratch using "last", after which a diff between them was performed to work out the span of the matches in \code{x} for each row in \code{i}. Most often we join to single rows, though, where "first","last" and "all" return the same result. We prefer maximum
performance for the majority of situations so the default chosen was "first". If you are working with a non-unique key then you need to specify "all".

In v1.4 the binary search in C was changed to branch at the deepest level to find first and last. Note that branch will likely occur within the same final pages. So there should no longer be a speed disadvantage in defaulting mult to 'all'. The 'all' default would be simpler and easier for the user as this FAQ comes up quite often.

A future version of \code{data.table} may allow a distinction between a key and a unique key. The \code{mult} argument could then be defaulted more
wisely.  \code{data.table} would then need to add checks on insert and update to make sure a unique key is maintained. That would be
one of the advantages to the user of specifying a unique key; i.e., \code{data.table} would make sure a duplicate could not be inserted.


Note that when \code{i} (or \code{i}'s key if it has one) has fewer columns than x's key,  mult is automatically set to "all". This is why
grouping by \code{i} works; e.g., \code{DT[J(id),mean(v)]} where \code{key(DT)} has 2 or more columns.

\subsection{I'm using \code{c()} in the j and getting strange results.}
This is a common source of confusion. In \code{data.frame} you are used to, for example:
<<>>=
df = data.frame(x=1:3,y=4:6,z=7:9)
df
df[,c("y","z")]
@
which returns the two columns. In \code{data.table} you know you can use the column names directly and might try :
<<>>=
dt = data.table(df)
dt[,c(y,z)]
@
but this returns one vector.  Remember that the \code{j} expression is evaluated within the environment of \code{dt},
and \code{c()} returns a vector.  If 2 or more columns are required, use list() instead:
<<>>=
dt[,list(y,z)]
@
\code{c()} can be useful in a \code{data.table} too, but its behaviour is different from that in a \code{data.frame}.

\subsection{I have built up a complex table with many columns.  I want to use it as a template for a new table; i.e., create
a new table with no rows, but with the column types copied from my table. Can I do that easily?}
Yes. If your complex table is called \code{DT}, try \code{DT[0]}.

\subsection{Is a NULL \code{data.table} the same as \code{DT[0]}?}
No, despite the print method indicating otherwise. Strictly speaking, it's not possible to have \code{is.null(data.table(NULL))}
return FALSE.  [Perhaps look at this again.]

\subsection{Why has the \code{DT()} alias been removed?}\label{faq:DTremove1}
\code{DT} was introduced originally as a wrapper for a list of \code{j} expressions. Since \code{DT} was an alias for \code{data.table}, this
was a convenient way to take care of silent recycling in cases where each item of the \code{j} list evaluated to different lengths. The alias was one reason grouping was slow, though.
As of v1.3, list() should be passed instead to the \code{j} argument. list() is a primitive and is much faster, especially when
there are many groups. Internally, this was a nontrivial change. Vector recycling is done internally, along with
several other speed enhancements for grouping.
Some users have come to rely on the \code{DT} alias, though. If there is a lot of code that depends on \code{DT()}, you can easily create
the alias yourself:
\code{DT = function(...) data.table(...)}

\subsection{But my code uses \code{j=DT(...)} and it works. The previous FAQ says that \code{DT()} has been removed.}\label{faq:DTremove2}
\code{[.data.table} inspects the \code{j} expression that is passed to it. If it finds that the expression starts with a call
to \code{DT()} it automatically replaces it with a call to \code{list()}. This is to help existing users. Please don't
use \code{j=data.table(...)} as that may be slow. Use \code{j=list(...)}.

\subsection{What are the scoping rules for j expressions?}
Think of the subset as an environment where all the column names are
variables. When a variable is used in the \code{j} expression, it is looked for in the following order :
\begin{enumerate}
\item The scope of the subset, i.e., the column names.
\item The scope of the calling frame; e.g., the line that appears before the \code{data.table} query.
\item Exercise for reader: does it then ripple up or go straight to .GlobalEnv?
\item The global environment .GlobalEnv
\end{enumerate}
This is \emph{lexical scoping} as explained in \href{http://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping}{R FAQ 3.3.1}.
The environment that the function was created is not relevant, though, because there is no function. No anonymous \emph{function}
is passed to the \code{j}. Instead, an anonymous \emph{body} is passed to the \code{j}; for example,
<<>>=
DT = data.table(x=rep(c("a","b"),c(2,3)),y=1:5)
DT
DT[,{z=sum(y);z+3},by=x]
@

\subsection{Can I trace the j expression as it runs through the groups?}
Try something like this:
<<>>=
DT[,{
  cat("Objects:",paste(objects(),collapse=","),"\n")
  cat("Trace: x=",as.character(x)," y=",y,"\n")
  sum(y)
},by=x]
@


\subsection{Inside each group, why is the group variable a long vector containing the same value repeated?}
This is correct. We saw that in the previous FAQ. x was \code{"a"} repeated twice in the first group, and \code{"b"}
repeated three times in the second group. When you group, think of the
data being split up. Sometimes we want to use the value of the group in
the expression, though. In that case, we just use the first value.
<<>>=
DT[,list(g=1,h=2,i=3,j=4,repeatgroupname=x,sum(y)),by=x]     # not intended
DT[,list(g=1,h=2,i=3,j=4,repeatgroupname=x[1],sum(y)),by=x]  # intended
@
In the first attempt, the aggregate \code{sum(y)} was recycled to match the length of \code{x}.  Recycling can be useful, but
wasn't intended here.

\subsection{Only the first 10 rows are printed, how do I print more?}
Try \code{print(DT,nrows=Inf)} to print all rows, or set nrows to the number of rows you require.

\subsection{With an \code{X[Y]} join, what if \code{X} contains a column called \code{"Y"}?}
When \code{i} is a single name such as \code{Y} it is evaluated in the calling frame. In all other cases such as calls to \code{J()} or other expressions, \code{i} is evaluated within the scope of \code{X}. This facilitates easy \emph{self joins} such as \code{X[J(unique(colA)),mult="first"]}.

\subsection{\code{X[Z[Y]]} is failing because \code{X} contains a column \code{"Y"}. I want it to use the table Y in calling scope.}
The \code{Z[Y]} part is not a single name so that is evaluated within the frame of \code{X} and the problem occurs. Try \code{tmp=Z[Y];X[tmp]}. This is robust to \code{X} containing a column \code{"tmp"} because \code{tmp} is a single name. If you often encounter conflics of this type, one simple solution may be to name all tables in uppercase and all column names in lowercase, or some similar scheme.

\section{Questions relating to compute time}

\subsection{I have 20 columns in \code{data.table} x. Why is an expression of one column so quick?}
Several reasons:
\begin{itemize}
\item Only that column is grouped, the other 19 are ignored because \code{data.table} inspects the j expression and realises it doesn't use the other columns.
\item One memory allocation is made for the largest group only, then that memory is re-used for the other groups, there is very little garbage to collect.
\item R is an in memory column store i.e. the columns are contiguous in RAM. Page fetches from RAM into L2 cache are minimised.
\end{itemize}

\subsection{I don't have a key on a large table, but grouping is still really quick. Why is that?}
\code{data.table} uses radix sorting. This is significantly faster than other sort algorithms.
Radix is specifically for integers only, see \code{?base::sort.list(x,method="radix")}.

This is also one reason why \code{setkey()} is quick.

When no key is set, or we group in a different order from that of the key, we call it an \emph{ad hoc by}.

\subsection{Why is grouping by columns in the key faster than an ad hoc by?}
Because each group is contiguous in RAM, thereby minimising page fetches, and memory can be
copied in bulk rather than looping.

\section{Error messages}
\subsection{\code{Could not find function "DT"}}
See FAQ \ref{faq:DTremove1} and FAQ \ref{faq:DTremove2}.

\subsection{I have created a package that depends on \code{data.table}. It works fine in development but when I release it as a package I get \code{data.frame} errors.}
Make sure you use \code{require(data.table)} rather than \code{library(data.table)}. The \code{require()}
function is very similar to \code{libary()} but also adds \code{data.table} to the hidden \code{.Depends} vector and this makes
your package \emph{data.table aware}. This is important from v1.5 when \code{data.table} started to
inherit from \code{data.frame}. Calls to \code{[.data.table} from non \code{data.table} aware packages, such as base
and ggplot2, are redirected to \code{[.data.frame} by \code{[.data.table}. When those packages use the usual \code{[.data.frame} syntax (e.g. \code{x[,5]}) when x is a \code{data.table}, x appears to behave as a \code{data.frame} would. You have likely been developing and testing your package in .GlobalEnv which is always considered \code{data.table} aware by \code{data.table}.

\subsection{Why does \code{[.data.table} now have a \code{drop} argument from v1.5?}
So that \code{data.table} can inherit from \code{data.frame} without using \code{...}. If we used \code{...} then
invalid argument names would not be caught and the convenience of test 147 would be lost.

The drop argument is never used by \code{[.data.table}; it is a placeholder for non \code{data.table} aware packages when they treat the \code{data.table} as if it were a \code{data.frame}. See previous FAQ.


\section{General questions about the package}

\subsection{v1.3 appears to be missing from the CRAN archive ?}
That is correct. v1.3 was available on R-Forge only. There were several large
changes internally and these took some time to test in development.

\subsection{Is \code{data.table} compatible with S-plus ?}
Not currently.
\begin{itemize}
\item A few core parts of the package are written in C and use internal \proglang{R} functions and \proglang{R} structures.
\item The package uses lexical scoping which is one of the differences between R and S-plus explained by
\href{http://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping}{R FAQ 3.3.1}.
\end{itemize}

\subsection{Is it available for Linux, Mac and Windows?}
Yes, for both 32-bit and 64-bit on all platforms. Thanks to CRAN and R-Forge. There are no special or OS-specific libraries used.

\subsection{I think it's great. What can I do?}
Please send suggestions, bug reports and enhancement requests to \href{mailto:datatable-help@lists.r-forge.r-project.org}{datatable-help@lists.r-forge.r-project.org}. 
This helps make the package better. The list is public and archived.

You can vote for packages at \url{http://crantastic.org/}. This helps encourage the developers. If
you have time to write a comment too, that helps others in the community; e.g., some users have
mentioned the types of data they use \code{data.table} to analyse.

You can join the project and change the code and/or documentation yourself.

\subsection{I think it's not great. How do I warn others about my experience?}
Please put your vote and comments on \url{http://crantastic.org/}. Make it constructive, so we have a chance to improve.

\subsection{I have a question. I know the posting guide tells me to contact the maintainer, but that's just one person. Isn't
there a group of people I can ask ?}
Yes. You can post to \href{mailto:datatable-help@lists.r-forge.r-project.org}{datatable-help@lists.r-forge.r-project.org}. It's
like r-help, but just for this package. Feel free to answer questions there, too.

\subsection{Where are the datatable-help archives?}
\url{http://lists.r-forge.r-project.org/pipermail/datatable-help/}

\subsection{I'd prefer not to contact datatable-help, can I mail just one or two people privately?}
Sure. You're more likely to get a faster answer from datatable-help, though.

\subsection{Why is this FAQ a pdf? Can we have the FAQ on a website?}
This FAQ is a vignette written using Sweave. The benefits of Sweave include the following:
\begin{itemize}
\item We include R code in the answers. This is actually run when the file is created, not copy and pasted. 
\item This document is reproducible. Grab the .Rnw and you can run it yourself.
\item This file is built every night on R-Forge so it's another way we check the package.
\item This file is bound into each version of the package. The package is not accepted on CRAN unless this file passes checks. Each version of the
package will have its own FAQ file which will be relevant for that version.  Contrast this to a single website, which can be ambiguous if the answer
depends on the version.
\item You can open it offline, from your R prompt using vignette().
\item You can extract the code from the document and play with it using\newline \code{edit(vignette("datatable-timings"))}.
\item It prints out easily.
\item It's quicker and easier for us to write and maintain the FAQ in .Rnw form.
\end{itemize}


\end{document}




